var documenterSearchIndex = {"docs":
[{"location":"api/types/#api-types","page":"Type Trees","title":"Type Trees","text":"","category":"section"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"The following code snippet provides an easy way to print the type tree of probabilistic circuits.","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"using InteractiveUtils;\nusing ProbabilisticCircuits;\nusing AbstractTrees;\nAbstractTrees.children(x::Type) = subtypes(x);","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"For example, we can see ProbabilisticCircuits.ProbCircuit's type tree.","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"AbstractTrees.print_tree(ProbCircuit)","category":"page"},{"location":"api/internals/probabilistic_circuits/#api-internal-probabilistic","page":"Probabilistic Circuits","title":"Probabilistic Circuits","text":"","category":"section"},{"location":"api/internals/probabilistic_circuits/","page":"Probabilistic Circuits","title":"Probabilistic Circuits","text":"Modules = [ProbabilisticCircuits]","category":"page"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.Categorical","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.Categorical","text":"A N-value categorical input distribution ranging over integers [0...N-1]\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.FlatVectors","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.FlatVectors","text":"An isbits representation of a AbstractVector{<:AbstractVector}\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.Indicator","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.Indicator","text":"A input distribution node that places all probability on a single value\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.Literal","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.Literal","text":"A logical literal input distribution node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.NodeType","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.NodeType","text":"Probabilistic circuit node types\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.NodeType-Tuple{ProbCircuit}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.NodeType","text":"Get the probabilistic circuit node type\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.PlainInnerNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.PlainInnerNode","text":"A probabilistic inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.PlainInputNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.PlainInputNode","text":"A probabilistic input node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.PlainMulNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.PlainMulNode","text":"A probabilistic multiplication node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.PlainProbCircuit","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.PlainProbCircuit","text":"Root of the plain probabilistic circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.PlainSumNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.PlainSumNode","text":"A probabilistic summation node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.ProbCircuit","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.ProbCircuit","text":"Root of the probabilistic circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.RegionGraph","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.RegionGraph","text":"Root of region graph node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#Base.read-Union{Tuple{C}, Tuple{AbstractString, Type{C}}} where C<:ProbCircuit","page":"Probabilistic Circuits","title":"Base.read","text":"Base.read(file::AbstractString, ::Type{C}) where C <: ProbCircuit\n\nReads circuit from file; uses extension to detect format type, for example \".psdd\" for PSDDs.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#Base.write-Tuple{AbstractString, ProbCircuit}","page":"Probabilistic Circuits","title":"Base.write","text":"Base.write(file::AbstractString, circuit::ProbCircuit)\n\nWrites circuit to file; uses file name extention to detect file format.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#DirectedAcyclicGraphs.foldup-Union{Tuple{T}, Tuple{ProbCircuit, Function, Function, Function, Type{T}}, Tuple{ProbCircuit, Function, Function, Function, Type{T}, Any}} where T","page":"Probabilistic Circuits","title":"DirectedAcyclicGraphs.foldup","text":"foldup(node::ProbCircuit, \n    f_i::Function, \n    f_m::Function, \n    f_s::Function)::T where {T}\n\nCompute a function bottom-up on the circuit.  f_in is called on input nodes, f_m is called on product nodes, and f_s is called on sum nodes. Values of type T are passed up the circuit and given to f_m and f_s through a callback from the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#DirectedAcyclicGraphs.foldup_aggregate-Union{Tuple{T}, Tuple{ProbCircuit, Function, Function, Function, Type{T}}, Tuple{ProbCircuit, Function, Function, Function, Type{T}, Any}} where T","page":"Probabilistic Circuits","title":"DirectedAcyclicGraphs.foldup_aggregate","text":"foldup_aggregate(node::ProbCircuit, \n    f_i::Function, \n    f_m::Function, \n    f_s::Function, \n    ::Type{T})::T where T\n\nCompute a function bottom-up on the circuit.  f_in is called on input nodes, f_m is called on product nodes, and f_s is called on sum nodes. Values of type T are passed up the circuit and given to f_m and f_s in an aggregate vector from the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.MAP-Tuple{ProbCircuit, Matrix{T} where T}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.MAP","text":"MAP(pc::ProbCircuit, data::Matrix; batch_size, Float=Float32)\n\nEvaluate max a posteriori (MAP) state of the circuit for given input(s) on cpu.\n\nNote: This algorithm is only exact if the circuit is both decomposable and determinisitic. If the circuit is only decomposable and not deterministic, this will give inexact results without guarantees.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.balance_sum-Tuple{Vector{ProbCircuit}, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.balance_sum","text":"Makes sure the sum nodes does not have too many children. Makes balanced sums of sums to reduce children count.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.balanced_fully_factorized_leaves-Tuple{AbstractVector{T} where T}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.balanced_fully_factorized_leaves","text":"Makes sure input nodes don't have too many parents. Makes a dummy sum node for each input per partition. Then nodes corresponding to the partition use the dummy node as their children instead of the input node. This way instead of numnodesroot * numnodesleaf, we would have numnodesroot parents nodes.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.cleanup_memory-Tuple{CUDA.CuArray, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.cleanup_memory","text":"Cleansup allocated memory. Used internally.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.dist","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.dist","text":"Get the distribution of a PC input node\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.eval_circuit!-Tuple{Any, AbstractVector{var\"#s110\"} where var\"#s110\"<:ProbCircuit, Matrix{T} where T, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.eval_circuit!","text":"eval_circuit!(mars, linPC::AbstractVector{<:ProbCircuit}, data::Matrix, example_ids;  node2idx::Dict{ProbCircuit, UInt32}, Float=Float32)\n\nUsed internally. Evaluates the marginals of the circuit on cpu. Stores the values in mars.\n\nmars: (batch_size, nodes)\nlinPC: linearized PC. (i.e. linearize(pc))\ndata: data Matrix (num_examples, features)\nexample_ids: Array or collection of ids for current batch\nnode2idx: Index of each ProbCircuit node in the linearized circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.eval_circuit_max!-Tuple{Any, AbstractVector{var\"#s23\"} where var\"#s23\"<:ProbCircuit, Matrix{T} where T, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.eval_circuit_max!","text":"eval_circuit_max!(mars, linPC::AbstractVector{<:ProbCircuit}, data::Matrix, example_ids;  node2idx::Dict{ProbCircuit, UInt32}, Float=Float32)\n\nUsed internally. Evaluates the MAP upward pass of the circuit on cpu. Stores the values in mars.\n\nmars: (batch_size, nodes)\nlinPC: linearized PC. (i.e. linearize(pc))\ndata: data Matrix (num_examples, features)\nexample_ids: Array or collection of ids for current batch\nnode2idx: Index of each ProbCircuit node in the linearized circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.full_batch_em-Tuple{ProbabilisticCircuits.CuBitsProbCircuit, CUDA.CuArray, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.full_batch_em","text":"full_batch_em(bpc::CuBitsProbCircuit, raw_data::CuArray, num_epochs; batch_size, pseudocount)\n\nUpdate the paramters of the CuBitsProbCircuit by doing EM on the full batch (i.e. update paramters at the end of each epoch).\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.hclt-Union{Tuple{T}, Tuple{Any, Any}} where T","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.hclt","text":"hclt(data, num_hidden_cats; num_cats = nothing, input_type = LiteralDist)\n\nLearns HiddenChowLiuTree (hclt) circuit structure from data.\n\ndata: Matrix or CuMatrix\nnum_hidden_cats: Number of categories in hidden variables\ninput_type: Distribution type for the inputs\nnum_cats: Number of categories (in case of categorical inputs). Automatically deduced if not given explicilty.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.init_parameters-Tuple{ProbCircuit}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.init_parameters","text":"init_parameters(pc::ProbCircuit; perturbation = 0.0)\n\nInitialize parameters of ProbCircuit.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.inputnodes-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.inputnodes","text":"Get all input nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.inputs","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.inputs","text":"Get the inputs of a PC node\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.isinput-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.isinput","text":"Is the node an input node?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.ismul-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.ismul","text":"Is the node a multiplication?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.isonlysubedge-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.isonlysubedge","text":"whether this sub edge is the only outgoing edge from sub\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.ispartial-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.ispartial","text":"whether this series of edges is partial or complete\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.issum-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.issum","text":"Is the node a summation?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.loglikelihood-Tuple{ProbCircuit, Matrix{T} where T, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.loglikelihood","text":"loglikelihood(root::ProbCircuit, data::Matrix, example_id; Float=Float32)\n\nComputes marginal loglikelihood recursively on cpu for a single instance data[example_id, :].\n\nNote: Quite slow, only use for demonstration/educational purposes. \n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.loglikelihood-Tuple{ProbabilisticCircuits.CuBitsProbCircuit, CUDA.CuArray}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.loglikelihood","text":"loglikelihood(bpc::CuBitsProbCircuit, data::CuArray; batch_size, mars_mem = nothing)\n\nComputes Average loglikelihood of circuit given the data using gpu. See loglikelihoods for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.loglikelihoods-Tuple{ProbCircuit, Matrix{T} where T}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.loglikelihoods","text":"loglikelihoods(pc::ProbCircuit, data::Matrix)\n\nComputes loglikelihoods of the circuit over the data on cpu. Linearizes the circuit and computes the marginals in batches.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.loglikelihoods-Tuple{ProbabilisticCircuits.CuBitsProbCircuit, CUDA.CuArray}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.loglikelihoods","text":"loglikelihoods(bpc::CuBitsProbCircuit, data::CuArray; batch_size, mars_mem = nothing)\n\nReturns loglikelihoods for each datapoint on gpu. Missing values should be denoted by missing.\n\nbpc: BitCircuit on gpu\ndata: CuArray{Union{Missing, data_types...}}\nbatch_size\nmars_mem: Not required, advanced usage. CuMatrix to reuse memory and reduce allocations. See prep_memory and cleanup_memory.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.loglikelihoods_vectorized-Tuple{ProbCircuit, Matrix{T} where T}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.loglikelihoods_vectorized","text":"Note: Experimental**; will be removed or renamed later\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.map_down_rec!-Tuple{Any, ProbCircuit, Any, Matrix{T} where T, Any, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.map_down_rec!","text":"map_down_rec!(mars, node::ProbCircuit, data, states::Matrix, batch_idx, example_idx; node2idx::Dict{ProbCircuit, UInt32}, Float=Float32)\n\nDownward pass on cpu for MAP. Recursively chooses the best (max) sum node children according to the \"MAP upward pass\" values. Updates the missing values with map_state of that input node.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.mini_batch_em-Tuple{ProbabilisticCircuits.CuBitsProbCircuit, CUDA.CuArray, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.mini_batch_em","text":"mini_batch_em(bpc::CuBitsProbCircuit, raw_data::CuArray, num_epochs; batch_size, pseudocount, \n    param_inertia, param_inertia_end = param_inertia, shuffle=:each_epoch)\n\nUpdate the parameters of the CuBitsProbCircuit by doing EM, update the parameters after each batch.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.mulnodes-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.mulnodes","text":"Get all multiplication nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.multiply","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.multiply","text":"Multiply nodes into a single circuit\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.num_inputs-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.num_inputs","text":"Number of inputs of a PC node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.num_parameters","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.num_parameters","text":"Count the number of parameters in the circuit\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.num_parameters_node-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.num_parameters_node","text":"Count the number of parameters in the node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.num_randvars-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.num_randvars","text":"Number of variables in the data structure\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.params-Tuple{ProbCircuit}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.params","text":"Get the parameters associated with a sum node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.prep_memory","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.prep_memory","text":"prep_memory(reuse, sizes, exact = map(x -> true, sizes))\n\nMostly used internally. Prepares memory for the specifed size, reuses reuse if possible to avoid memory allocation/deallocation.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.psdd_num_nodes_leafs-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.psdd_num_nodes_leafs","text":"Count the number of decision and leaf nodes in the PSDD\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.random_region_graph-Tuple{AbstractVector{T} where T}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.random_region_graph","text":"random_region_graph(X::AbstractVector, depth::Int = 5, replicas::Int = 2, num_splits::Int = 2)\n\nX: Vector of all variables to include; for the root region\ndepth: how many layers to do splits\nreplicas: number of replicas or paritions (replicas only used for the root region; for other regions only 1 parition (inner nodes), or 0 parition for leaves)\nnum_splits: number of splits for each parition; split variables into random equaly sized regions\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.randvars","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.randvars","text":"variables(pc::ProbCircuit)::BitSet\n\nGet a bitset of variables mentioned in the circuit.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.region_graph_2_pc-Tuple{RegionGraph}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.region_graph_2_pc","text":"region_graph_2_pc(node::RegionGraph; num_nodes_root, num_nodes_region, num_nodes_leaf, balance_childs_parents)\n\nnum_nodes_root: number of sum nodes in the root region\nnum_nodes_leaf: number of sum nodes per leaf region\nnum_nodes_region: number of in each region except root and leaves\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.sample-Tuple{ProbCircuit, Any, Matrix{T} where T}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.sample","text":"sample(pc::ProbCircuit, num_samples; rng = default_rng())\n\nGenerate num_samples from the joint distribution of the circuit conditined on the data.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.sample-Tuple{ProbCircuit, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.sample","text":"sample(pc::ProbCircuit, num_samples; rng = default_rng())\n\nGenerate num_samples from the joint distribution of the circuit without any conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.soften_data-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.soften_data","text":"Turn binary data into floating point data close to 0 and 1.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.summate","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.summate","text":"Sum nodes into a single circuit\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.sumnodes-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.sumnodes","text":"Get all summation nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.update_parameters-Tuple{ProbabilisticCircuits.AbstractBitsProbCircuit}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.update_parameters","text":"map parameters from BitsPC back to the ProbCircuit it was created from\n\n\n\n\n\n","category":"method"},{"location":"manual/queries/#man-queries","page":"Queries","title":"Queries","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"In this section, we go over most common probabilistic reasoning tasks, and provide code snippets to compute those queries. ","category":"page"},{"location":"manual/queries/#Setup","page":"Queries","title":"Setup","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"First, we load some pretrained PC, and the corresponding data.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"# This is needed to hide output from downloading artifacts\nusing LogicCircuits # hide\nusing ProbabilisticCircuits; #hide\npc = zoo_psdd(\"plants.psdd\")\ndata, _, _ = twenty_datasets(\"plants\");","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"using LogicCircuits # hide\nusing ProbabilisticCircuits; #hide\npc = zoo_psdd(\"plants.psdd\")\ndata, _, _ = twenty_datasets(\"plants\");\nprintln(\"circuit with $(num_nodes(pc)) nodes and $(num_parameters(pc)) parameters.\")\nprintln(\"dataset with $(num_features(data)) features and $(num_examples(data)) examples.\")","category":"page"},{"location":"manual/queries/#Full-Evidence-(EVI)","page":"Queries","title":"Full Evidence (EVI)","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"EVI refers to computing the probability when full evidence is given, i.e. when x is fully observed, the output is p(x). We can use EVI method to compute logp(x):","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"probs = EVI(pc, data);\nprobs[1:3]","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Computing the EVI of a mixture of circuits works the same way. You may either pass weights for the weighted mixture probability, or pass a component index to individually evaluate each component.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"mix, mix_weights, _ = learn_strudel(data; num_mix = 10, init_maxiter = 10, em_maxiter = 100)\n# This computes the weighted probability\nprobs = EVI(mix, data, mix_weights);\n# Alternatively, we may want to compute the probability of a single component\nc_prob = EVI(mix, data; component_idx = 1);\nc_prob[1:3]","category":"page"},{"location":"manual/queries/#Partial-Evidence-(MAR)","page":"Queries","title":"Partial Evidence (MAR)","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"In this case we have some missing values. Let x^o denote the observed features, and x^m the missing features. We would like to compute p(x^o) which is defined as p(x^o) = sum_x^m p(x^o x^m). Of course, computing this directly by summing over all possible ways to fill the missing values is not tractable. ","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"The good news is that given a smooth and decomposable PC, the marginal can be computed exactly and in linear time to the size of the PC.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"First, we randomly make some features go missing (you can also use make_missing_mcar from LogicCircuits library):","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"using DataFrames\nusing Tables\nfunction make_missing(d::DataFrame; keep_prob=0.8)\n    m = missings(Bool, num_examples(d), num_features(d))\n    flag = rand(num_examples(d), num_features(d)) .<= keep_prob\n    m[flag] .= Tables.matrix(d)[flag]\n    DataFrame(m, :auto)\nend;\ndata_miss = make_missing(data[1:1000,:]);\nnothing #hide","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Now, we can use MAR to compute the marginal queries:","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"probs = MAR(pc, data_miss);\nprobs[1:3]","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Note that MAR can also be used to compute probabilisties even if all data is observed, in fact it should give the same results as EVI. However, if we know all features are observed, we suggest using EVI as its faster in general.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"probs_mar = MAR(pc, data);\nprobs_evi = EVI(pc, data);\n\nprobs_mar â‰ˆ probs_evi","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Just like EVI, MAR works the same way for mixtures.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"# Full weighted marginal probability\nprobs_mar = MAR(mix, data, mix_weights);\n# Individual component's marginal probability\nc_probs_mar = MAR(mix, data; component_idx = 1);\nc_probs_mar[1:3]","category":"page"},{"location":"manual/queries/#Conditionals-(CON)","page":"Queries","title":"Conditionals (CON)","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"In this case, given observed features x^o, we would like to compute p(Q mid x^o), where Q is a subset of features disjoint with x^o.  We can use Bayes rule to compute conditionals as two seperate MAR queries as follows:","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"p(q mid x^o) = cfracp(q x^o)p(x^o)","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Currently, this has to be done manually by the user. We plan to add a simple API for this case in the future.","category":"page"},{"location":"manual/queries/#Maximum-a-posteriori-(MAP,-MPE)","page":"Queries","title":"Maximum a posteriori (MAP, MPE)","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"In this case, given the observed features x^o the goal is to fill out the missing features in a way that p(x^m x^o) is maximized.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"We can use the MAP method to compute MAP, which outputs the states that maximize the probability and the log-likelihoods of each state.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"data_miss = make_missing(data,keep_prob=0.5);\nstates, probs = MAP(pc, data_miss);\nprobs[1:3]","category":"page"},{"location":"manual/queries/#Sampling","page":"Queries","title":"Sampling","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"We can also sample from the distrubtion p(x) defined by a Probabilistic Circuit. You can use sample to achieve this task.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"samples, _ = sample(pc, 100);\nsize(samples)","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Additionally, we can do conditional samples x sim p(x mid x^o), where x^o are the observed features (x^o subseteq x), and could be any arbitrary subset of features.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"#3 random evidences for the examples\nevidence = DataFrame(rand( (missing,true,false), (2, num_variables(pc))), :auto)\n\nsamples, _ = sample(pc, 3, evidence);\nsize(samples)","category":"page"},{"location":"manual/queries/#Expected-Prediction-(EXP)","page":"Queries","title":"Expected Prediction (EXP)","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Expected Prediction (EXP) is the task of taking expectation of a discrimintative model w.r.t a generative model conditioned on evidemce (subset of features observed).","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"mathbbE_x^m sim p(x^m mid x^o)  f(x^o x^m) ","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"In the case where f and p are circuit, and some structural constrains for the pair, we can do this expectation and higher moments tractably.  You can use Expectation and Moment to compute the expectations.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"using DiscriminativeCircuits\nusing DataFrames\n\npc = zoo_psdd(\"insurance.psdd\")\nrc = zoo_dc(\"insurance.circuit\")\n\n# Using samples from circuit for the example; replace with real data\ndata, _ = sample(pc, 10);\ndata = make_missing(DataFrame(data, :auto));\n\nexps, exp_cache = Expectation(pc, rc, data)\n\nexps[1:3]","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"second_moments, moment_cache = Moment(pc, rc, data, 2);\nexps[1:3]","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"stds = sqrt.( second_moments - exps.^2 );\nstds[1:3]","category":"page"},{"location":"manual/learning/#man-learning","page":"Learning","title":"Learning","text":"","category":"section"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"In this section we provide few learning scenarios for circuits. In general, learning tasks for PCs can be separted into two categories: parameter learning and structure learning.","category":"page"},{"location":"manual/learning/#Structures","page":"Learning","title":"Structures","text":"","category":"section"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"Currently we are supporting the following structures:","category":"page"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"HiddenChowLiuTrees: See hclt.\nRAT-SPNs: See random_region_graph, and region_graph_2_pc.","category":"page"},{"location":"manual/learning/#Parameter-Learning","page":"Learning","title":"Parameter Learning","text":"","category":"section"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"Currently we are supporting the following parameters learning APIs:","category":"page"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"mini_batch_em\nfull_batch_em","category":"page"},{"location":"manual/learning/#Future-Docs","page":"Learning","title":"Future Docs","text":"","category":"section"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"Learning a circuit from missing data\nLearn a mixture of circuits\nLearn a circuit from logical constraints and data","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#Prerequisites","page":"Installation","title":"Prerequisites","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia 1.6 or greater. For installation, please refer to the official Julia Website.","category":"page"},{"location":"installation/#Installing-ProbabilisticCircuits","page":"Installation","title":"Installing ProbabilisticCircuits","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"You can use Julia's package manager, Pkg, to install this module and its dependencies. There are different options on how to do that, for example through command line or julia REPL. For more information and options on how to use Julia pacakge manager, please refer to Pkg's Documentation.","category":"page"},{"location":"installation/#From-Command-Line","page":"Installation","title":"From Command Line","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the latest stable release, run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia -e 'using Pkg; Pkg.add(\"ProbabilisticCircuits\")'","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"You can also install the package with the latest commits on master branch.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia -e 'using Pkg; Pkg.add([PackageSpec(url=\"https://github.com/Juice-jl/ProbabilisticCircuits.jl.git\")])'","category":"page"},{"location":"installation/#From-Package-mode","page":"Installation","title":"From Package mode","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"note: Note\nTo get to Pkg mode, you need to run julia, then to press ]. Press backspace or ^C to get back to normal REPL mode.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"While in Pkg mode, run the following to install the latest release:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"add ProbabilisticCircuits","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Similarly, to install from the latest commits on master branch, run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"add ProbabilisticCircuits#master","category":"page"},{"location":"installation/#Testing","page":"Installation","title":"Testing","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you are installing the latest commit, we recommend running the test suite to make sure everything is in order, to do that run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia --color=yes -e 'using Pkg; Pkg.test(\"ProbabilisticCircuits\")'","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Note: If you want the tests to run faster, you can use multiple cores. To do that set the following environment variable (default = 1 core):","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"export JIVE_PROCS=8","category":"page"},{"location":"manual/demo/#man-demo","page":"Quick Demo","title":"Quick Demo","text":"","category":"section"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"In this section, we provide quick code snippets to get started with ProbabilisticCircuits and provide basic understanding of them. PCs are represented as a computational graphs that define a joint probability distribution as recursive mixtures (sum units) and factorizations (product units) of simpler distributions (input units).","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"Generally, we learn structure and parameters of circuit from data. Alternatively, we can also specify circuits in code. For example, the following snippet defines a circuit depending on 3 random variables. The literals function returns the input units of the circuit, in this case we get 6 different units (3 for positive literals, and 3 for negative literlas).  You can use * and + operators to build a circuits.","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"using ProbabilisticCircuits;\n\nX1, X2, X3 = [ProbabilisticCircuits.PlainInputNode(i, Indicator(true)) for i=1:3]\nX1_, X2_, X3_ = [ProbabilisticCircuits.PlainInputNode(i, Indicator(false)) for i=1:3]\n\npc = 0.3 * (X1_ *\n             (0.2 * X2_ + 0.8 * X3)) +\n     0.7 * (X1 *\n             (0.4 * X2 + 0.6 * X3_));\n\nnothing # hide","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"You can ask basic questions about PCs, such as (1) how many variables they depends on, (2) how many nodes, (3) how many edges, (4) or how many parameters they have.","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"num_randvars(pc)","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"num_nodes(pc)","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"num_edges(pc)","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"num_parameters(pc)","category":"page"},{"location":"#ProbabilisticCircuits.jl","page":"Home","title":"ProbabilisticCircuits.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This module provides a Julia implementation of Probabilistic Circuits (PCs),  tools to learn structure and parameters of PCs from data, and tools to do tractable exact inference with them. ","category":"page"},{"location":"#What-are-Probabilistic-Circuits?","page":"Home","title":"What are Probabilistic Circuits?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Probabilistic Circuits provides a unifying framework for several family of tractable probabilistic models. PCs are represented as a computational graphs that define a joint probability distribution as recursive mixtures (sum units) and factorizations (product units) of simpler distributions (input units).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Given certain structural properties, PCs enable different range of tractable exact probabilistic queries such as computing marginals, conditionals, maximum a posteriori (MAP), and more advanced probabilistic queries.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In additon to parameters, the structure of PCs can also be learned from data. There are several approaches in learning PCs, while keeping the needed structural constrains intact. Currently, This module includes implementation for few of these approaches with plans to add more over time.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, parallelism (on both CPU and GPU) is leveraged to provide faster implementation of learning and inference.","category":"page"},{"location":"#Where-to-learn-more-about-them?","page":"Home","title":"Where to learn more about them?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For an overview of the motivation and theory behind PCs, you can start by watching the ECML-PKDD tutorial on Probabilistic Circuits. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Probabilistic Circuits: Representations, Inference, Learning and Theory (Video)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more details and additional references, you can refer to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Probabilistic Circuits: A Unifying Framework for Tractable Probabilistic Models (PDF)","category":"page"},{"location":"api/public/#api-public","page":"Public APIs","title":"Public APIs","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"This page lists documentation for the most commonly used public APIs of ProbabilisticCircuits.jl. Visit the internals section for a auto generated documentation for more public API and internal APIs.","category":"page"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"Pages = [\"public.md\"]","category":"page"},{"location":"api/public/#Circuit-IO","page":"Public APIs","title":"Circuit IO","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"read\nwrite","category":"page"},{"location":"api/public/#Base.read","page":"Public APIs","title":"Base.read","text":"Base.read(file::AbstractString, ::Type{C}) where C <: ProbCircuit\n\nReads circuit from file; uses extension to detect format type, for example \".psdd\" for PSDDs.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Base.write","page":"Public APIs","title":"Base.write","text":"Base.write(file::AbstractString, circuit::ProbCircuit)\n\nWrites circuit to file; uses file name extention to detect file format.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Learning-Circuits","page":"Public APIs","title":"Learning Circuits","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"mini_batch_em\nfull_batch_em","category":"page"},{"location":"api/public/#ProbabilisticCircuits.mini_batch_em","page":"Public APIs","title":"ProbabilisticCircuits.mini_batch_em","text":"mini_batch_em(bpc::CuBitsProbCircuit, raw_data::CuArray, num_epochs; batch_size, pseudocount, \n    param_inertia, param_inertia_end = param_inertia, shuffle=:each_epoch)\n\nUpdate the parameters of the CuBitsProbCircuit by doing EM, update the parameters after each batch.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ProbabilisticCircuits.full_batch_em","page":"Public APIs","title":"ProbabilisticCircuits.full_batch_em","text":"full_batch_em(bpc::CuBitsProbCircuit, raw_data::CuArray, num_epochs; batch_size, pseudocount)\n\nUpdate the paramters of the CuBitsProbCircuit by doing EM on the full batch (i.e. update paramters at the end of each epoch).\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Circuit-Queries","page":"Public APIs","title":"Circuit Queries","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"loglikelihood\nloglikelihoods","category":"page"},{"location":"api/public/#ProbabilisticCircuits.loglikelihood","page":"Public APIs","title":"ProbabilisticCircuits.loglikelihood","text":"loglikelihood(bpc::CuBitsProbCircuit, data::CuArray; batch_size, mars_mem = nothing)\n\nComputes Average loglikelihood of circuit given the data using gpu. See loglikelihoods for more details.\n\n\n\n\n\nloglikelihood(root::ProbCircuit, data::Matrix, example_id; Float=Float32)\n\nComputes marginal loglikelihood recursively on cpu for a single instance data[example_id, :].\n\nNote: Quite slow, only use for demonstration/educational purposes. \n\n\n\n\n\n","category":"function"},{"location":"api/public/#ProbabilisticCircuits.loglikelihoods","page":"Public APIs","title":"ProbabilisticCircuits.loglikelihoods","text":"loglikelihoods(bpc::CuBitsProbCircuit, data::CuArray; batch_size, mars_mem = nothing)\n\nReturns loglikelihoods for each datapoint on gpu. Missing values should be denoted by missing.\n\nbpc: BitCircuit on gpu\ndata: CuArray{Union{Missing, data_types...}}\nbatch_size\nmars_mem: Not required, advanced usage. CuMatrix to reuse memory and reduce allocations. See prep_memory and cleanup_memory.\n\n\n\n\n\nloglikelihoods(pc::ProbCircuit, data::Matrix)\n\nComputes loglikelihoods of the circuit over the data on cpu. Linearizes the circuit and computes the marginals in batches.\n\n\n\n\n\n","category":"function"}]
}
