var documenterSearchIndex = {"docs":
[{"location":"api/common/#api-common","page":"Common APIs","title":"Common APIs","text":"","category":"section"},{"location":"api/common/","page":"Common APIs","title":"Common APIs","text":"This page lists documentation for the most commonly used functions of ProbabilisticCircuits.jl. Visit the internals section for a auto generated documentation for all APIs.","category":"page"},{"location":"api/common/","page":"Common APIs","title":"Common APIs","text":"Pages = [\"common.md\"]","category":"page"},{"location":"api/common/#Circuit-IO","page":"Common APIs","title":"Circuit IO","text":"","category":"section"},{"location":"api/common/","page":"Common APIs","title":"Common APIs","text":"read\nwrite","category":"page"},{"location":"api/common/#Base.read","page":"Common APIs","title":"Base.read","text":"Base.read(file::AbstractString, ::Type{C}) where C <: ProbCircuit\n\nReads circuit from file; uses extension to detect format type, for example \".psdd\" for PSDDs.\n\n\n\n\n\n","category":"function"},{"location":"api/common/#Base.write","page":"Common APIs","title":"Base.write","text":"Base.write(file::AbstractString, circuit::ProbCircuit)\n\nWrites circuit to file; uses file name extention to detect file format.\n\n\n\n\n\n","category":"function"},{"location":"api/common/#Circuit-Structures","page":"Common APIs","title":"Circuit Structures","text":"","category":"section"},{"location":"api/common/","page":"Common APIs","title":"Common APIs","text":"hclt\nRAT","category":"page"},{"location":"api/common/#ProbabilisticCircuits.hclt","page":"Common APIs","title":"ProbabilisticCircuits.hclt","text":"hclt(data, num_hidden_cats; num_cats = nothing, input_type = LiteralDist)\n\nLearns HiddenChowLiuTree (hclt) circuit structure from data.\n\ndata: Matrix or CuMatrix\nnum_hidden_cats: Number of categories in hidden variables\ninput_type: Distribution type for the inputs\nnum_cats: Number of categories (in case of categorical inputs). Automatically deduced if not given explicilty.\n\n\n\n\n\n","category":"function"},{"location":"api/common/#ProbabilisticCircuits.RAT","page":"Common APIs","title":"ProbabilisticCircuits.RAT","text":"RAT(num_features; input_type = Literal, num_nodes_region, num_nodes_leaf, rg_depth, rg_replicas, num_nodes_root = 1, balance_childs_parents = true)\n\nGenerate a RAT-SPN structure. First, it generates a random region graph with depth, and replicas.  Then uses the random region graph to generate a ProbCircuit conforming to that region graph.\n\nThe list of hyperparamters are:\n\nrg_depth: how many layers to do splits in the region graph\nrg_replicas: number of replicas or paritions (replicas only used for the root region; for other regions only 1 parition (inner nodes), or 0 parition for leaves)\nnum_nodes_root: number of sum nodes in the root region\nnum_nodes_leaf: number of sum nodes per leaf region\nnum_nodes_region: number of in each region except root and leaves\nnum_splits: number of splits for each parition; split variables into random equaly sized regions\n\n\n\n\n\n","category":"function"},{"location":"api/common/#Learning-Circuit-Parameters","page":"Common APIs","title":"Learning Circuit Parameters","text":"","category":"section"},{"location":"api/common/","page":"Common APIs","title":"Common APIs","text":"mini_batch_em\nfull_batch_em","category":"page"},{"location":"api/common/#ProbabilisticCircuits.mini_batch_em","page":"Common APIs","title":"ProbabilisticCircuits.mini_batch_em","text":"mini_batch_em(bpc::CuBitsProbCircuit, raw_data::CuArray, num_epochs; batch_size, pseudocount, \n    param_inertia, param_inertia_end = param_inertia, shuffle=:each_epoch)\n\nUpdate the parameters of the CuBitsProbCircuit by doing EM, update the parameters after each batch.\n\n\n\n\n\n","category":"function"},{"location":"api/common/#ProbabilisticCircuits.full_batch_em","page":"Common APIs","title":"ProbabilisticCircuits.full_batch_em","text":"full_batch_em(bpc::CuBitsProbCircuit, raw_data::CuArray, num_epochs; batch_size, pseudocount)\n\nUpdate the paramters of the CuBitsProbCircuit by doing EM on the full batch (i.e. update paramters at the end of each epoch).\n\n\n\n\n\n","category":"function"},{"location":"api/common/#Circuit-Queries","page":"Common APIs","title":"Circuit Queries","text":"","category":"section"},{"location":"api/common/","page":"Common APIs","title":"Common APIs","text":"loglikelihood\nloglikelihoods\nMAP\nsample","category":"page"},{"location":"api/common/#ProbabilisticCircuits.loglikelihood","page":"Common APIs","title":"ProbabilisticCircuits.loglikelihood","text":"loglikelihood(bpc::CuBitsProbCircuit, data::CuArray; batch_size, mars_mem = nothing)\n\nComputes Average loglikelihood of circuit given the data using gpu. See loglikelihoods for more details.\n\n\n\n\n\nloglikelihood(root::ProbCircuit, data::Matrix, example_id; Float=Float32)\n\nComputes marginal loglikelihood recursively on cpu for a single instance data[example_id, :].\n\nNote: Quite slow, only use for demonstration/educational purposes. \n\n\n\n\n\n","category":"function"},{"location":"api/common/#ProbabilisticCircuits.loglikelihoods","page":"Common APIs","title":"ProbabilisticCircuits.loglikelihoods","text":"loglikelihoods(bpc::CuBitsProbCircuit, data::CuArray; batch_size, mars_mem = nothing)\n\nReturns loglikelihoods for each datapoint on gpu. Missing values should be denoted by missing.\n\nbpc: BitCircuit on gpu\ndata: CuArray{Union{Missing, data_types...}}\nbatch_size\nmars_mem: Not required, advanced usage. CuMatrix to reuse memory and reduce allocations. See prep_memory and cleanup_memory.\n\n\n\n\n\nloglikelihoods(pc::ProbCircuit, data::Matrix)\n\nComputes loglikelihoods of the circuit over the data on cpu. Linearizes the circuit and computes the marginals in batches.\n\n\n\n\n\n","category":"function"},{"location":"api/common/#ProbabilisticCircuits.MAP","page":"Common APIs","title":"ProbabilisticCircuits.MAP","text":"MAP(bpc::CuBitsProbCircuit, data::CuArray; batch_size, mars_mem=nothing)\n\nRetruns the MAP states for a given circuit and data on gpu. Missing values should be denoted as missing.\n\nNote that the MAP states are exact only when the circuit is both decomposable and deterministic, otherwise its just an approximation.\n\nbpc: BitCircuit on gpu\ndata: CuArray{Union{Missing, data_types...}}\nbatch_size\nmars_mem: Not required, advanced usage. CuMatrix to reuse memory and reduce allocations. See prep_memory and cleanup_memory.\n\n\n\n\n\nMAP(pc::ProbCircuit, data::Matrix; batch_size, Float=Float32)\n\nEvaluate max a posteriori (MAP) state of the circuit for given input(s) on cpu.\n\nNote: This algorithm is only exact if the circuit is both decomposable and determinisitic. If the circuit is only decomposable and not deterministic, this will give inexact results without guarantees.\n\n\n\n\n\n","category":"function"},{"location":"api/common/#ProbabilisticCircuits.sample","page":"Common APIs","title":"ProbabilisticCircuits.sample","text":"sample(bpc::CuBitsProbCircuit, num_samples, num_samples::Int, num_rand_vars::Int, types; rng=default_rng())\n\nGenerate num_samples from the joint distribution of the circuit without any conditions. Samples are genearted on the GPU. \n\nbpc: Circuit on gpu (CuBitProbCircuit)\nnum_samples: how many samples to generate\nnum_rand_vars: number of random variables in the circuit\ntypes: Array of possible input types\nrng: (Optional) Random Number Generator\n\nThe size of returned Array is (num_samples, 1, size(data, 2)).\n\n\n\n\n\nsample(bpc::CuBitsProbCircuit, num_samples, data::CuMatrix; rng=default_rng())\n\nGenerate num_samples for each datapoint in data from the joint distribution of the circuit conditioned on the data. Samples are generated using GPU. \n\nbpc: Circuit on gpu (CuBitProbCircuit)\nnum_samples: how many samples to generate\nrng: (Optional) Random Number Generator\n\nThe size of returned CuArray is (num_samples, size(data, 1), size(data, 2)).\n\n\n\n\n\nsample(pc::ProbCircuit, num_samples; rng = default_rng())\n\nGenerate num_samples from the joint distribution of the circuit without any conditions. Samples are generated on the CPU.\n\n\n\n\n\nsample(pc::ProbCircuit, num_samples; rng = default_rng())\n\nGenerate num_samples from the joint distribution of the circuit conditioned on the data.\n\n\n\n\n\n","category":"function"},{"location":"manual/gpu/#man-gpu","page":"GPU Support","title":"GPU Support","text":"","category":"section"},{"location":"manual/gpu/","page":"GPU Support","title":"GPU Support","text":"Most queries and learning APIs support both CPU and GPU implementations. To use the GPU implementations you need to move the circuit and the dataset to GPU, then call the corresponding API.","category":"page"},{"location":"manual/gpu/#Moving-to-GPU","page":"GPU Support","title":"Moving to GPU","text":"","category":"section"},{"location":"manual/gpu/#Moving-Data-to-GPU","page":"GPU Support","title":"Moving Data to GPU","text":"","category":"section"},{"location":"manual/gpu/","page":"GPU Support","title":"GPU Support","text":"Currently, the APIs support CuArray type of gpu implemetations. One simple way to move to gpu is using the cu function from CUDA.jl.","category":"page"},{"location":"manual/gpu/","page":"GPU Support","title":"GPU Support","text":"using CUDA\ntrain_x_gpu, test_x_gpu = cu.(train_x, test_x)","category":"page"},{"location":"manual/gpu/","page":"GPU Support","title":"GPU Support","text":"In case of missing values we use Missing type, so for example if you have categorical features with some missing values, the data type on gpu would be CuArray{Union{Missing, UInt32}}.","category":"page"},{"location":"manual/gpu/#Moving-Circuit-to-GPU","page":"GPU Support","title":"Moving Circuit to GPU","text":"","category":"section"},{"location":"manual/gpu/","page":"GPU Support","title":"GPU Support","text":"ProbCircuits are stored in DAG structure and are not GPU friendly by default. So, we convert them into BitsProbCircuits (or bit circuits) as a lower level representation that is GPU friendly. The GPU version of bit circuits has type CuBitsProbCircuit, so to move your circuit to GPU you can simply do:","category":"page"},{"location":"manual/gpu/","page":"GPU Support","title":"GPU Support","text":"bpc = CuBitsProbCircuit(circuit);","category":"page"},{"location":"manual/gpu/#GPU-APIs","page":"GPU Support","title":"GPU APIs","text":"","category":"section"},{"location":"manual/gpu/","page":"GPU Support","title":"GPU Support","text":"The GPU supported APIs generally have the same name as their CPU counterpart, for a comprehensive list of supported functions see the API documentation. For example, we support the following on gpu:","category":"page"},{"location":"manual/gpu/","page":"GPU Support","title":"GPU Support","text":"sample\nMAP\nloglikelihoods\nmini_batch_em\nfull_batch_em","category":"page"},{"location":"api/types/#api-types","page":"Type Trees","title":"Type Trees","text":"","category":"section"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"The following code snippet provides an easy way to print the type tree of probabilistic circuits.","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"using InteractiveUtils;\nusing ProbabilisticCircuits;\nusing AbstractTrees;\nAbstractTrees.children(x::Type) = subtypes(x);","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"For example, we can see ProbabilisticCircuits.ProbCircuit's type tree.","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"AbstractTrees.print_tree(ProbCircuit)","category":"page"},{"location":"api/internals/probabilistic_circuits/#api-internal-probabilistic","page":"Probabilistic Circuits","title":"Probabilistic Circuits","text":"","category":"section"},{"location":"api/internals/probabilistic_circuits/","page":"Probabilistic Circuits","title":"Probabilistic Circuits","text":"Modules = [ProbabilisticCircuits]","category":"page"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.Categorical","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.Categorical","text":"A N-value categorical input distribution ranging over integers [0...N-1]\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.FlatVectors","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.FlatVectors","text":"An isbits representation of a AbstractVector{<:AbstractVector}\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.Indicator","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.Indicator","text":"A input distribution node that places all probability on a single value\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.Literal","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.Literal","text":"A logical literal input distribution node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.NodeType","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.NodeType","text":"Probabilistic circuit node types\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.NodeType-Tuple{ProbCircuit}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.NodeType","text":"Get the probabilistic circuit node type\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.PlainInnerNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.PlainInnerNode","text":"A probabilistic inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.PlainInputNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.PlainInputNode","text":"A probabilistic input node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.PlainMulNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.PlainMulNode","text":"A probabilistic multiplication node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.PlainProbCircuit","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.PlainProbCircuit","text":"Root of the plain probabilistic circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.PlainSumNode","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.PlainSumNode","text":"A probabilistic summation node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.ProbCircuit","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.ProbCircuit","text":"Root of the probabilistic circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.RegionGraph","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.RegionGraph","text":"Root of region graph node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/probabilistic_circuits/#Base.read-Union{Tuple{C}, Tuple{AbstractString, Type{C}}} where C<:ProbCircuit","page":"Probabilistic Circuits","title":"Base.read","text":"Base.read(file::AbstractString, ::Type{C}) where C <: ProbCircuit\n\nReads circuit from file; uses extension to detect format type, for example \".psdd\" for PSDDs.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#Base.write-Tuple{AbstractString, ProbCircuit}","page":"Probabilistic Circuits","title":"Base.write","text":"Base.write(file::AbstractString, circuit::ProbCircuit)\n\nWrites circuit to file; uses file name extention to detect file format.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#DirectedAcyclicGraphs.foldup-Union{Tuple{T}, Tuple{ProbCircuit, Function, Function, Function, Type{T}}, Tuple{ProbCircuit, Function, Function, Function, Type{T}, Any}} where T","page":"Probabilistic Circuits","title":"DirectedAcyclicGraphs.foldup","text":"foldup(node::ProbCircuit, \n    f_i::Function, \n    f_m::Function, \n    f_s::Function)::T where {T}\n\nCompute a function bottom-up on the circuit.  f_in is called on input nodes, f_m is called on product nodes, and f_s is called on sum nodes. Values of type T are passed up the circuit and given to f_m and f_s through a callback from the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#DirectedAcyclicGraphs.foldup_aggregate-Union{Tuple{T}, Tuple{ProbCircuit, Function, Function, Function, Type{T}}, Tuple{ProbCircuit, Function, Function, Function, Type{T}, Any}} where T","page":"Probabilistic Circuits","title":"DirectedAcyclicGraphs.foldup_aggregate","text":"foldup_aggregate(node::ProbCircuit, \n    f_i::Function, \n    f_m::Function, \n    f_s::Function, \n    ::Type{T})::T where T\n\nCompute a function bottom-up on the circuit.  f_in is called on input nodes, f_m is called on product nodes, and f_s is called on sum nodes. Values of type T are passed up the circuit and given to f_m and f_s in an aggregate vector from the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.MAP-Tuple{CuBitsProbCircuit, CUDA.CuArray}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.MAP","text":"MAP(bpc::CuBitsProbCircuit, data::CuArray; batch_size, mars_mem=nothing)\n\nRetruns the MAP states for a given circuit and data on gpu. Missing values should be denoted as missing.\n\nNote that the MAP states are exact only when the circuit is both decomposable and deterministic, otherwise its just an approximation.\n\nbpc: BitCircuit on gpu\ndata: CuArray{Union{Missing, data_types...}}\nbatch_size\nmars_mem: Not required, advanced usage. CuMatrix to reuse memory and reduce allocations. See prep_memory and cleanup_memory.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.MAP-Tuple{ProbCircuit, Matrix{T} where T}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.MAP","text":"MAP(pc::ProbCircuit, data::Matrix; batch_size, Float=Float32)\n\nEvaluate max a posteriori (MAP) state of the circuit for given input(s) on cpu.\n\nNote: This algorithm is only exact if the circuit is both decomposable and determinisitic. If the circuit is only decomposable and not deterministic, this will give inexact results without guarantees.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.RAT-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.RAT","text":"RAT(num_features; input_type = Literal, num_nodes_region, num_nodes_leaf, rg_depth, rg_replicas, num_nodes_root = 1, balance_childs_parents = true)\n\nGenerate a RAT-SPN structure. First, it generates a random region graph with depth, and replicas.  Then uses the random region graph to generate a ProbCircuit conforming to that region graph.\n\nThe list of hyperparamters are:\n\nrg_depth: how many layers to do splits in the region graph\nrg_replicas: number of replicas or paritions (replicas only used for the root region; for other regions only 1 parition (inner nodes), or 0 parition for leaves)\nnum_nodes_root: number of sum nodes in the root region\nnum_nodes_leaf: number of sum nodes per leaf region\nnum_nodes_region: number of in each region except root and leaves\nnum_splits: number of splits for each parition; split variables into random equaly sized regions\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.balance_sum-Tuple{Vector{ProbCircuit}, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.balance_sum","text":"Makes sure the sum nodes does not have too many children. Makes balanced sums of sums to reduce children count.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.balanced_fully_factorized_leaves-Tuple{AbstractVector{T} where T}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.balanced_fully_factorized_leaves","text":"Makes sure input nodes don't have too many parents. Makes a dummy sum node for each input per partition. Then nodes corresponding to the partition use the dummy node as their children instead of the input node. This way instead of numnodesroot * numnodesleaf, we would have numnodesroot parents nodes.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.cleanup_memory-Tuple{CUDA.CuArray, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.cleanup_memory","text":"Cleansup allocated memory. Used internally.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.dist","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.dist","text":"Get the distribution of a PC input node\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.eval_circuit!-Tuple{Any, AbstractVector{var\"#s110\"} where var\"#s110\"<:ProbCircuit, Matrix{T} where T, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.eval_circuit!","text":"eval_circuit!(mars, linPC::AbstractVector{<:ProbCircuit}, data::Matrix, example_ids;  node2idx::Dict{ProbCircuit, UInt32}, Float=Float32)\n\nUsed internally. Evaluates the marginals of the circuit on cpu. Stores the values in mars.\n\nmars: (batch_size, nodes)\nlinPC: linearized PC. (i.e. linearize(pc))\ndata: data Matrix (num_examples, features)\nexample_ids: Array or collection of ids for current batch\nnode2idx: Index of each ProbCircuit node in the linearized circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.eval_circuit_max!-Tuple{Any, AbstractVector{var\"#s23\"} where var\"#s23\"<:ProbCircuit, Matrix{T} where T, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.eval_circuit_max!","text":"eval_circuit_max!(mars, linPC::AbstractVector{<:ProbCircuit}, data::Matrix, example_ids;  node2idx::Dict{ProbCircuit, UInt32}, Float=Float32)\n\nUsed internally. Evaluates the MAP upward pass of the circuit on cpu. Stores the values in mars.\n\nmars: (batch_size, nodes)\nlinPC: linearized PC. (i.e. linearize(pc))\ndata: data Matrix (num_examples, features)\nexample_ids: Array or collection of ids for current batch\nnode2idx: Index of each ProbCircuit node in the linearized circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.full_batch_em-Tuple{CuBitsProbCircuit, CUDA.CuArray, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.full_batch_em","text":"full_batch_em(bpc::CuBitsProbCircuit, raw_data::CuArray, num_epochs; batch_size, pseudocount)\n\nUpdate the paramters of the CuBitsProbCircuit by doing EM on the full batch (i.e. update paramters at the end of each epoch).\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.hclt-Tuple{Any, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.hclt","text":"hclt(data, num_hidden_cats; num_cats = nothing, input_type = LiteralDist)\n\nLearns HiddenChowLiuTree (hclt) circuit structure from data.\n\ndata: Matrix or CuMatrix\nnum_hidden_cats: Number of categories in hidden variables\ninput_type: Distribution type for the inputs\nnum_cats: Number of categories (in case of categorical inputs). Automatically deduced if not given explicilty.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.init_parameters-Tuple{ProbCircuit}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.init_parameters","text":"init_parameters(pc::ProbCircuit; perturbation = 0.0)\n\nInitialize parameters of ProbCircuit.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.inputnodes-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.inputnodes","text":"Get all input nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.inputs-Tuple{Any, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.inputs","text":"Get the inputs of a PC node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.isinput-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.isinput","text":"Is the node an input node?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.ismul-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.ismul","text":"Is the node a multiplication?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.isonlysubedge-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.isonlysubedge","text":"whether this sub edge is the only outgoing edge from sub\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.ispartial-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.ispartial","text":"whether this series of edges is partial or complete\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.issum-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.issum","text":"Is the node a summation?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.loglikelihood-Tuple{CuBitsProbCircuit, CUDA.CuArray}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.loglikelihood","text":"loglikelihood(bpc::CuBitsProbCircuit, data::CuArray; batch_size, mars_mem = nothing)\n\nComputes Average loglikelihood of circuit given the data using gpu. See loglikelihoods for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.loglikelihood-Tuple{ProbCircuit, Matrix{T} where T, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.loglikelihood","text":"loglikelihood(root::ProbCircuit, data::Matrix, example_id; Float=Float32)\n\nComputes marginal loglikelihood recursively on cpu for a single instance data[example_id, :].\n\nNote: Quite slow, only use for demonstration/educational purposes. \n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.loglikelihoods-Tuple{CuBitsProbCircuit, CUDA.CuArray}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.loglikelihoods","text":"loglikelihoods(bpc::CuBitsProbCircuit, data::CuArray; batch_size, mars_mem = nothing)\n\nReturns loglikelihoods for each datapoint on gpu. Missing values should be denoted by missing.\n\nbpc: BitCircuit on gpu\ndata: CuArray{Union{Missing, data_types...}}\nbatch_size\nmars_mem: Not required, advanced usage. CuMatrix to reuse memory and reduce allocations. See prep_memory and cleanup_memory.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.loglikelihoods-Tuple{ProbCircuit, Matrix{T} where T}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.loglikelihoods","text":"loglikelihoods(pc::ProbCircuit, data::Matrix)\n\nComputes loglikelihoods of the circuit over the data on cpu. Linearizes the circuit and computes the marginals in batches.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.loglikelihoods_vectorized-Tuple{ProbCircuit, Matrix{T} where T}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.loglikelihoods_vectorized","text":"Note: Experimental**; will be removed or renamed later\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.map_down_rec!-Tuple{Any, ProbCircuit, Any, Matrix{T} where T, Any, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.map_down_rec!","text":"map_down_rec!(mars, node::ProbCircuit, data, states::Matrix, batch_idx, example_idx; node2idx::Dict{ProbCircuit, UInt32}, Float=Float32)\n\nDownward pass on cpu for MAP. Recursively chooses the best (max) sum node children according to the \"MAP upward pass\" values. Updates the missing values with map_state of that input node.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.mini_batch_em-Tuple{CuBitsProbCircuit, CUDA.CuArray, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.mini_batch_em","text":"mini_batch_em(bpc::CuBitsProbCircuit, raw_data::CuArray, num_epochs; batch_size, pseudocount, \n    param_inertia, param_inertia_end = param_inertia, shuffle=:each_epoch)\n\nUpdate the parameters of the CuBitsProbCircuit by doing EM, update the parameters after each batch.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.mulnodes-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.mulnodes","text":"Get all multiplication nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.multiply","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.multiply","text":"Multiply nodes into a single circuit\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.num_inputs-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.num_inputs","text":"Number of inputs of a PC node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.num_parameters","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.num_parameters","text":"Count the number of parameters in the circuit\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.num_parameters_node-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.num_parameters_node","text":"Count the number of parameters in the node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.num_randvars-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.num_randvars","text":"Number of variables in the data structure\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.params-Tuple{ProbCircuit}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.params","text":"Get the parameters associated with a node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.prep_memory","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.prep_memory","text":"prep_memory(reuse, sizes, exact = map(x -> true, sizes))\n\nMostly used internally. Prepares memory for the specifed size, reuses reuse if possible to avoid memory allocation/deallocation.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.psdd_num_nodes_leafs-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.psdd_num_nodes_leafs","text":"Count the number of decision and leaf nodes in the PSDD\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.random_region_graph-Tuple{AbstractVector{T} where T}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.random_region_graph","text":"random_region_graph(X::AbstractVector, depth::Int = 5, replicas::Int = 2, num_splits::Int = 2)\n\nX: Vector of all variables to include; for the root region\ndepth: how many layers to do splits\nreplicas: number of replicas or paritions (replicas only used for the root region; for other regions only 1 parition (inner nodes), or 0 parition for leaves)\nnum_splits: number of splits for each parition; split variables into random equaly sized regions\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.randvars","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.randvars","text":"variables(pc::ProbCircuit)::BitSet\n\nGet a bitset of variables mentioned in the circuit.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.region_graph_2_pc-Tuple{RegionGraph}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.region_graph_2_pc","text":"region_graph_2_pc(node::RegionGraph; num_nodes_root, num_nodes_region, num_nodes_leaf, balance_childs_parents)\n\nnum_nodes_root: number of sum nodes in the root region\nnum_nodes_leaf: number of sum nodes per leaf region\nnum_nodes_region: number of in each region except root and leaves\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.sample-Tuple{CuBitsProbCircuit, Any, CUDA.CuArray{T, 2, B} where {T, B}}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.sample","text":"sample(bpc::CuBitsProbCircuit, num_samples, data::CuMatrix; rng=default_rng())\n\nGenerate num_samples for each datapoint in data from the joint distribution of the circuit conditioned on the data. Samples are generated using GPU. \n\nbpc: Circuit on gpu (CuBitProbCircuit)\nnum_samples: how many samples to generate\nrng: (Optional) Random Number Generator\n\nThe size of returned CuArray is (num_samples, size(data, 1), size(data, 2)).\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.sample-Tuple{CuBitsProbCircuit, Int64, Int64, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.sample","text":"sample(bpc::CuBitsProbCircuit, num_samples, num_samples::Int, num_rand_vars::Int, types; rng=default_rng())\n\nGenerate num_samples from the joint distribution of the circuit without any conditions. Samples are genearted on the GPU. \n\nbpc: Circuit on gpu (CuBitProbCircuit)\nnum_samples: how many samples to generate\nnum_rand_vars: number of random variables in the circuit\ntypes: Array of possible input types\nrng: (Optional) Random Number Generator\n\nThe size of returned Array is (num_samples, 1, size(data, 2)).\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.sample-Tuple{ProbCircuit, Any, Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.sample","text":"sample(pc::ProbCircuit, num_samples; rng = default_rng())\n\nGenerate num_samples from the joint distribution of the circuit without any conditions. Samples are generated on the CPU.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.sample-Tuple{ProbCircuit, Any, Matrix{T} where T}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.sample","text":"sample(pc::ProbCircuit, num_samples; rng = default_rng())\n\nGenerate num_samples from the joint distribution of the circuit conditioned on the data.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.soften_data-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.soften_data","text":"Turn binary data into floating point data close to 0 and 1.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.summate","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.summate","text":"Sum nodes into a single circuit\n\n\n\n\n\n","category":"function"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.sumnodes-Tuple{Any}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.sumnodes","text":"Get all summation nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/probabilistic_circuits/#ProbabilisticCircuits.update_parameters-Tuple{ProbabilisticCircuits.AbstractBitsProbCircuit}","page":"Probabilistic Circuits","title":"ProbabilisticCircuits.update_parameters","text":"map parameters from BitsPC back to the ProbCircuit it was created from\n\n\n\n\n\n","category":"method"},{"location":"manual/queries/#man-queries","page":"Queries","title":"Queries","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"In this section, we go over most common probabilistic reasoning tasks, and provide code snippets to compute those queries.","category":"page"},{"location":"manual/queries/#Setup","page":"Queries","title":"Setup","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"First, we load some pretrained PC, and the corresponding data.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"# This is needed to hide output from downloading artifacts\nusing CircuitModelZoo; #hide\nusing ProbabilisticCircuits; #hide\nusing DensityEstimationDatasets; #hide\npc = read(zoo_psdd_file(\"plants.psdd\"), ProbCircuit);\ndata, _, _ = twenty_datasets(\"plants\");","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"using CircuitModelZoo: zoo_psdd_file\nusing DensityEstimationDatasets: twenty_datasets\nusing ProbabilisticCircuits\nusing Tables\n\npc = read(zoo_psdd_file(\"plants.psdd\"), ProbCircuit);\ndata, _, _ = twenty_datasets(\"plants\");\ndata = Tables.matrix(data);\nprintln(\"circuit with $(num_nodes(pc)) nodes and $(num_parameters(pc)) parameters.\")\nprintln(\"dataset with $(size(data, 2)) features and $(size(data, 1)) examples.\")","category":"page"},{"location":"manual/queries/#Full-Evidence-(EVI)","page":"Queries","title":"Full Evidence (EVI)","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"EVI refers to computing the probability when full evidence is given, i.e. when x is fully observed, the output is p(x). We can use loglikelihoods method to compute logp(x):","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"probs = loglikelihoods(pc, data[1:100, :]; batch_size=64);\nprobs[1:3]","category":"page"},{"location":"manual/queries/#Partial-Evidence-(MAR)","page":"Queries","title":"Partial Evidence (MAR)","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"In this case we have some missing values. Let x^o denote the observed features, and x^m the missing features. We would like to compute p(x^o) which is defined as p(x^o) = sum_x^m p(x^o x^m). Of course, computing this directly by summing over all possible ways to fill the missing values is not tractable. ","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"The good news is that given a smooth and decomposable PC, the marginal can be computed exactly and in linear time to the size of the PC.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"First, we randomly make some features go missing.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"using DataFrames\nusing Tables\nfunction make_missing(d; keep_prob=0.8)\n    m = missings(Bool, size(d)...)\n    flag = rand(size(d)...) .<= keep_prob\n    m[flag] .= d[flag]\n    return m\nend;\ndata_miss = make_missing(data[1:1000,:]);\nnothing #hide","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Now, we can use loglikelihoods to compute the marginal queries.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"probs = loglikelihoods(pc, data_miss; batch_size=64);\nprobs[1:3]","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Note that loglikelihoods can also be used to compute probabilisties if all data is observed, as we saw in previous section.","category":"page"},{"location":"manual/queries/#Conditionals-(CON)","page":"Queries","title":"Conditionals (CON)","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"In this case, given observed features x^o, we would like to compute p(Q mid x^o), where Q is a subset of features disjoint with x^o.  We can use Bayes rule to compute conditionals as two seperate MAR queries as follows:","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"p(q mid x^o) = cfracp(q x^o)p(x^o)","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Currently, this has to be done manually by the user. We plan to add a simple API for this case in the future.","category":"page"},{"location":"manual/queries/#Maximum-a-posteriori-(MAP,-MPE)","page":"Queries","title":"Maximum a posteriori (MAP, MPE)","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"In this case, given the observed features x^o the goal is to fill out the missing features in a way that p(x^m x^o) is maximized.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"We can use the MAP method to compute MAP, which outputs the states that maximize the probability and the log-likelihoods of each state.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"data_miss = make_missing(data[1:1000,:], keep_prob=0.5);\nstates = MAP(pc, data_miss; batch_size = 64);\nsize(states)","category":"page"},{"location":"manual/queries/#Sampling","page":"Queries","title":"Sampling","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"We can also sample from the distrubtion p(x) defined by a Probabilistic Circuit. You can use sample to achieve this task.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"samples = sample(pc, 100, [Bool]);\nsize(samples)","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Additionally, we can do conditional samples x sim p(x mid x^o), where x^o are the observed features (x^o subseteq x), and could be any arbitrary subset of features.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"#3 random evidences for the examples\nevidence = rand( (missing,true,false), (2, num_randvars(pc)));\n\nsamples = sample(pc, 3, evidence; batch_size = 2);\nsize(samples)","category":"page"},{"location":"manual/learning/#man-learning","page":"Learning","title":"Learning","text":"","category":"section"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"In this section we provide few learning scenarios for circuits. In general, learning tasks for PCs can be separted into two categories: parameter learning and structure learning.","category":"page"},{"location":"manual/learning/#Structures","page":"Learning","title":"Structures","text":"","category":"section"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"Currently we are supporting the following structures:","category":"page"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"HiddenChowLiuTrees: See hclt.\nRAT-SPNs: See RAT.","category":"page"},{"location":"manual/learning/#Parameter-Learning","page":"Learning","title":"Parameter Learning","text":"","category":"section"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"Currently we are supporting the following parameters learning APIs:","category":"page"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"mini_batch_em\nfull_batch_em","category":"page"},{"location":"manual/learning/#Future-Docs","page":"Learning","title":"Future Docs","text":"","category":"section"},{"location":"manual/learning/","page":"Learning","title":"Learning","text":"Learning a circuit from missing data\nLearn a mixture of circuits\nLearn a circuit from logical constraints and data","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#Prerequisites","page":"Installation","title":"Prerequisites","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia 1.6 or greater. For installation, please refer to the official Julia Website.","category":"page"},{"location":"installation/#Installing-ProbabilisticCircuits","page":"Installation","title":"Installing ProbabilisticCircuits","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"You can use Julia's package manager, Pkg, to install this module and its dependencies. There are different options on how to do that, for example through command line or julia REPL. For more information and options on how to use Julia pacakge manager, please refer to Pkg's Documentation.","category":"page"},{"location":"installation/#From-Command-Line","page":"Installation","title":"From Command Line","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the latest stable release, run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia -e 'using Pkg; Pkg.add(\"ProbabilisticCircuits\")'","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"You can also install the package with the latest commits on master branch.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia -e 'using Pkg; Pkg.add([PackageSpec(url=\"https://github.com/Juice-jl/ProbabilisticCircuits.jl.git\")])'","category":"page"},{"location":"installation/#From-Package-mode","page":"Installation","title":"From Package mode","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"note: Note\nTo get to Pkg mode, you need to run julia, then to press ]. Press backspace or ^C to get back to normal REPL mode.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"While in Pkg mode, run the following to install the latest release:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"add ProbabilisticCircuits","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Similarly, to install from the latest commits on master branch, run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"add ProbabilisticCircuits#master","category":"page"},{"location":"installation/#Testing","page":"Installation","title":"Testing","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you are installing the latest commit, we recommend running the test suite to make sure everything is in order, to do that run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia --color=yes -e 'using Pkg; Pkg.test(\"ProbabilisticCircuits\")'","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Note: If you want the tests to run faster, you can use multiple cores. To do that set the following environment variable (default = 1 core):","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"export JIVE_PROCS=8","category":"page"},{"location":"manual/demo/#man-demo","page":"Quick Demo","title":"Quick Demo","text":"","category":"section"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"In this section, we provide quick code snippets to get started with ProbabilisticCircuits and provide basic understanding of them. PCs are represented as a computational graphs that define a joint probability distribution as recursive mixtures (sum units) and factorizations (product units) of simpler distributions (input units).","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"Generally, we learn structure and parameters of circuit from data. Alternatively, we can also specify circuits in code. For example, the following snippet defines a circuit depending on 3 random variables. The literals function returns the input units of the circuit, in this case we get 6 different units (3 for positive literals, and 3 for negative literlas).  You can use * and + operators to build a circuits.","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"using ProbabilisticCircuits;\n\nX1, X2, X3    = [InputNode(i, Indicator(true))  for i=1:3]\nX1_, X2_, X3_ = [InputNode(i, Indicator(false)) for i=1:3]\n\npc = 0.3 * (X1_ *\n             (0.2 * X2_ + 0.8 * X3)) +\n     0.7 * (X1 *\n             (0.4 * X2 + 0.6 * X3_));\n\nnothing # hide","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"You can ask basic questions about PCs, such as (1) how many variables they depends on, (2) how many nodes, (3) how many edges, (4) or how many parameters they have.","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"num_randvars(pc)","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"num_nodes(pc)","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"num_edges(pc)","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"num_parameters(pc)","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"We can also plot circuits using plot(pc) to see the computation graph (structure and parameters). The output of plot(pc) has a type of TikzPictures.TikzPicture. Generally, notebooks automatically renders it and you see the figure in the notebook. ","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"plot(pc)","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"However, if you are not using a notebook or want to save to file you can use the following commands to save the plot in various formats.","category":"page"},{"location":"manual/demo/","page":"Quick Demo","title":"Quick Demo","text":"using TikzPictures;\nz = plot(pc);\nsave(PDF(\"plot\"), z);\nsave(SVG(\"plot\"), z);\nsave(TEX(\"plot\"), z);\nsave(TIKZ(\"plot\"), z);","category":"page"},{"location":"#ProbabilisticCircuits.jl","page":"Home","title":"ProbabilisticCircuits.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This module provides a Julia implementation of Probabilistic Circuits (PCs),  tools to learn structure and parameters of PCs from data, and tools to do tractable exact inference with them. ","category":"page"},{"location":"#What-are-Probabilistic-Circuits?","page":"Home","title":"What are Probabilistic Circuits?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Probabilistic Circuits provides a unifying framework for several family of tractable probabilistic models. PCs are represented as a computational graphs that define a joint probability distribution as recursive mixtures (sum units) and factorizations (product units) of simpler distributions (input units).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Given certain structural properties, PCs enable different range of tractable exact probabilistic queries such as computing marginals, conditionals, maximum a posteriori (MAP), and more advanced probabilistic queries.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In additon to parameters, the structure of PCs can also be learned from data. There are several approaches in learning PCs, while keeping the needed structural constrains intact. Currently, This module includes implementation for few of these approaches with plans to add more over time.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, parallelism (on both CPU and GPU) is leveraged to provide faster implementation of learning and inference.","category":"page"},{"location":"#Where-to-learn-more-about-them?","page":"Home","title":"Where to learn more about them?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For an overview of the motivation and theory behind PCs, you can start by watching the ECML-PKDD tutorial on Probabilistic Circuits. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Probabilistic Circuits: Representations, Inference, Learning and Theory (Video)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more details and additional references, you can refer to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Probabilistic Circuits: A Unifying Framework for Tractable Probabilistic Models (PDF)","category":"page"}]
}
